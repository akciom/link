-- Copyright 2020 -- Scott Smith --
-- 
-- Animation Library. Takes a sprite sheet generated by Aseprite and turns it
-- into something digestable by LÃ–VE.
--TODO: accept sprite atlases
--TODO: generic invalid image frame that all sprites reference
--      * space saving, so each sprite doesn't need an extra frame in atlas

local setmetatable = setmetatable
local random = math.random
local sfmt = string.format

local lg = love.graphics
local json = require "json"

local AG = hal_conf.AG

local m = {}

local DEFAULT_LOOP_IDX = 1
local TAG_SIZE = 4

local function update_quad(quad, state, dt) --{{{
	if not state:find("^[%w_]+$") then error("invalid state name") end

	local timer = quad.timer + dt

	if timer >= quad.data.duration or state ~= quad.state then
		local bframe, eframe
		local direction = "forward"

		local idx = quad.idx + 1
		--print(state, "UPDATE QUAD1:", quad.state,"<>",  quad.loop_state, idx)

		local tags = quad.data.tags
		local tagidx

		do
			local old_state = quad.state
			local new_state = state

			if old_state ~= new_state then
				local next_loop_state = "NEVER_SET"--new loopstate
				quad.ready = true
				if not tagidx then
					tagidx = tags.name[sfmt("%s:end.%s", old_state, new_state)]
					next_loop_state = old_state..":end."
--TODO:Use ratio of completed start animation to set index when entering end tag
--
--notes:  if start animation has only ran for three out of four frames,
--the end animation should start on the 2nd frame in.
--
--local oldls = quad.loop_state
--if oldls == ":start" then
--   start_frame = floor((ratio of start frames played) * (total num end frames))
--   bframe = start frame for end frame
--   idx = bframe + start_frame
--end
				end
				if not tagidx then
					tagidx = tags.name[sfmt("%s:start", new_state)]
					next_loop_state = ":start"
				end
				if not tagidx then
					tagidx = tags.name[sfmt("%s:loop", new_state)]
					next_loop_state = ":loop"
				end
				if not tagidx then
					tagidx = tags.name[sfmt("%s:once", new_state)]
					next_loop_state = ":once"
					quad.ready = false
				end
				if not tagidx then
					tagidx = tags.name[new_state]
					next_loop_state = ""
				end
				if tagidx then
					idx = DEFAULT_LOOP_IDX
				else
					next_loop_state = ""
				end
				quad.loop_state = next_loop_state
				quad.state = state
				--states are now the same, next_loop_state is ready
			end
		end

		if not tagidx then
			local ls = quad.loop_state
			--print("NOT TAGIDX, QUAD/LOOP_STATE", quad.state, ls)
			local tagname = quad.state
			if ls == "" then
				tagidx = tags.name[tagname]
			end
			if ls == ":start" then
				tagname = quad.state .. ls
				tagidx = tags.name[tagname]
				eframe = tags[tagidx+2]
				if idx > eframe then
					ls = ":loop"
				end
			elseif ls:find(":end%.$") then
				tagname = ls .. quad.state
				tagidx = tags.name[tagname]
				--print("ENDTAGNAME", ls, quad.state, tagname, tagidx)
				eframe = tags[tagidx+2]
				--print("IDX, eframe", idx, eframe)
				if idx >= eframe then
					ls = ""
					 --so next pass will find either a "", ":start",
					 --or ":loop" loop_state
					quad.state = "none"
				end
			end
			if ls == ":loop" then
				tagname = quad.state .. ls
				tagidx = tags.name[tagname]
			end
			if ls == ":once" then
				tagname = quad.state .. ls
				tagidx = tags.name[tagname]
				eframe = tags[tagidx+2]
				if idx > eframe then
					idx = eframe
					quad.ready = true
				end
			end
			--print("TAG NAME", ls, tagname, tags.name[tagname])
			quad.loop_state = ls
		end

		if tagidx then
			bframe = tags[tagidx+1]
			eframe = tags[tagidx+2]
			local ls = quad.loop_state
			if idx == DEFAULT_LOOP_IDX and ls == "" then
				--any animation that doesn't need a :start or :end should be
				--able to start any where in the animation and it'll look fine.
				--At least this is the assumption that I'm going to make. If
				--this is not the desired behavior, then add the :loop suffix.
				--
				--This so enemy assets look more random. Say, when a few of them
				--enter an idle animation at the same time, animations will
				--start on a random frame.
				idx = bframe + random(0, eframe - bframe)
			end
		else
			bframe, eframe = DEFAULT_LOOP_IDX, DEFAULT_LOOP_IDX
		end
		--print("tag", state, tags[tagidx], bframe, eframe, direction)
		--direction: forward
		if idx < bframe or idx > eframe then idx = bframe end
		--TODO:direction: backward
		--TODO:direction: ping-pong
		quad.idx = idx
		timer = 0
		--print(state, "UPDATE QUAD2:", quad.state,"<>",  quad.loop_state, idx)
	end
	--if quad.state == "forward" and quad.loop_state == ":loop" then error("FORWARD") end
	quad.timer = timer
	return quad
end --}}}
-- update animation to next frame
function m:update(state, dt)
	--TODO:inline update_quad
	return update_quad(self.animation_state, state, dt)

	--instead of returning a quad, this function could update a spritebatch
	--although, this should update all animations at once and add them all
	--to the same sprite batch if I'm really going to do it properly
end

local sprite_data_memoize = {}

function m:release()
	local anim = self.animation_state
	local fname = anim.data.fname
	local data = sprite_data_memoize[fname]
	sprite_data_memoize[fname] = nil
	data.sprite:release()
	data.sprite = nil
	self.tex = nil
	for i = 1, #data.quads do
		data.quads[i]:release()
		data.quads[i] = nil
	end
	data.quads = nil
	self.quad = nil
end

function m:mt__index(name)
	if name == "quad" then
		if self.tex then
			local anim = self.animation_state
			return anim.data[anim.idx]
		end
		return nil
	end
	return m[name]
end

local f = {}

--TODO:organize quads, sprite_data, tags, etc. it's a mess
local function load_sprite_sheet(fname) --{{{
	if sprite_data_memoize[fname] then
		--print("Reusing existing sprite data: "..fname)
		local sdm = sprite_data_memoize[fname]
		return sdm.sprite, sdm.quads
	end
	local sprite = love.graphics.newImage(AG.assets.."/"..fname..".png")
	sprite:setFilter("linear", "nearest")

	local data do
		local f = io.open(AG.assets.."/"..fname..".json")
		local js
		if f then
			js = f:read("*a")
			f:close()
		else
			error("unable to open sprite meta data")
		end
		if js then
			data = json.decode(js)
		else
			error("unable to parse sprite meta data")
		end
	end

	if type(data) ~= "table" then
		error("invalid data for new_quad")
	end
	if #data.frames == 0 then
		error("invalid data format. export as array NOT hash")
	end

	local quad = {}
	quad.fname = fname
	local sprite_data = quad
	do --quad
		do --frame tags
			local tags = {count = 0, name = {}}
			quad.tags = tags

			local c = tags.count
			for i = 1, #data.meta.frameTags do
				local ft = data.meta.frameTags[i]
				local lname = ft.name:lower()
				tags.name[lname] = c
				tags[c+1] = ft.from + 1
				tags[c+2] = ft.to + 1
				tags[c+3] = lname
				tags[c+4] = ft.direction
				c = c + TAG_SIZE
			end
			tags.count = c
		end
		local duration = data.frames[1].duration
		local source_size = data.frames[1].sourceSize
		local w, h = sprite:getDimensions()
		for i = 1, #data.frames do
			local df = data.frames[i]
			--duration = df.duration

			local f = df.frame
			quad[i] = lg.newQuad(f.x,f.y, f.w,f.h, w, h)
			--print("newquad", i, quad[i])
		end
		quad.duration = duration / 1000
		quad.source_size = source_size
	end

	sprite_data_memoize[fname] = {
		sprite = sprite,
		quads = sprite_data,
	}
	return sprite, sprite_data
end --}}}

function f:get_memoized_data()
	return sprite_data_memoize
end

function f:load(sprite_name, color, w_or_label, w_or_h, h)
	local t = {}
	--TODO:maybe the Animation class should only handle textures
	t.color = color
	if type(w_or_label) == "number" then
		--assume it's just a rectangle
		t.w = w_or_label
		t.h = w_or_h
	elseif type(w_or_label) == "string" then
		--assume it's a label, may have a rectangle
		t.label = w_or_label
		t.w = w_or_h
		t.h = h
	end

	if not sprite_name then
		--without a sprite, no metatable is needed
		return t
	end
	
	--TODO: Inline load_sprite_sheet
	local texture, quads = load_sprite_sheet(sprite_name)
	--set data.sprite
	t.tex = texture
	t.w = quads.source_size.w
	t.h = quads.source_size.h

	--TODO:animation data: probably should be in a component
	--set data.quad
	local anim = {
		data = quads,
		idx = 1,
		timer = 0,
		state = "idle",
		loop_state = "",
		ready = true,
	}

	local tagidx = quads.tags.name[anim.state]
	if tagidx then
		anim.idx = quads.tags[tagidx+1]
	end
	t.animation_state = anim

	return setmetatable(t, {__index = m.mt__index})
end

return setmetatable(f, {__call = f.load})
