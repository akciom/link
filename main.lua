-- Copywrite 2020 -- Scott Smith --

--TODO: switch from package.path to love.filesystem.setRequirePath
local engine_src_dir = "./data"
package.path = "./data/?.lua;./data/?/init.lua;"
local tracestrip = "^%s*%./data/"
local thisfilestrip = "^%s*main%.lua:"

DEBUG = true

--main2: true, load once; false, load on each reset
--TODO:setting main2, maybe the logic should be switched...
local main2 = not hal_conf.reload_main2_on_restart

local require = require
package.path = package.path .. "/usr/local/share/lua/5.1/?.lua;"
if hal_conf.websocket_enabled then -- obs remote control
	local ev = require "ev"
	require "socket"
	require "ltn12"
	require "mime"

	hal_client = require "websocket.client".ev()

	hal_client:on_open(function() print("connected") end)
	hal_client:on_message(function(ws, msg)
		print("received", msg)
	end)
	hal_client:connect(hal_conf.ws_url, hal_conf.ws_protocol)
	ev.Idle.new(function(loop) loop:unloop() end):start(ev.Loop.default)
	ev.Loop.default:loop()
end
if hal_conf.midi and love.system.getOS() == "Linux" then
	local alsa = require "midialsa"
	alsa.client("Akciom Engine", 1, 1)
	alsa.connectfrom(0, hal_conf.midi_control)
	alsa.connectto(1, hal_conf.midi_control)
	halmidi_saved = {}
end

--global of all ffi.cdefs and if they have been initialized
--A ctype/metatype can only be created once
hal_defined = {}

--{{{ [[ GLOBAL VARIABLES printf, printftime, log ]]
local export_hal = { debug = {} }
printf = require "utils.printf"
printftime = require "utils.logging".time
log = require"utils.logging"({ hal = export_hal })
local printf, printftime = printf, printftime
--}}}

---{{{ [[ local variable declaration ]]
local assert, next, xpcall = assert, next, xpcall
local table, debug, string = table, debug, string
local collectgarbage = collectgarbage
local love = love
local lg = love.graphics
local reloadkind = false
--}}}

do
	local global_saved = {} for k,v in next, _G do global_saved[k] = v end
	require"strict"("export", _G)

	if main2 and type(main2) == "boolean" then
		print("** only .agpack and include files are reloaded")
		reloadkind = ".agpack"
		main2 = require"main2"
		global_saved.hal = hal
		global_saved.keys2 = keys2
	else
		print("** main2 will be reloaded")
		reloadkind = "main2"
	end

--{{{ [[ love.handlers: reload/quit ]]

	local package_loaded_saved = {}
	for k,v in next, package.loaded do
		package_loaded_saved[k] = v
	end

	function love.handlers.reload(donoterror)
		printftime("Reloading %s...", reloadkind)

		printf("(%dKB -->", collectgarbage("count"))
		for i = 1, 10 do
			collectgarbage()
		end
		collectgarbage("stop")
		printf(" %dKB)", collectgarbage("count"))
		collectgarbage("stop")

		export("clear", "all")
		for k,v in next, global_saved do
			export[k] = v
		end

		local pl = package.loaded
		for k,v in next, pl do
			pl[k] = package_loaded_saved[k]
		end
		print("done!\n          --------------------")
		if donoterror == "donoterror" then
			--was likely called explicitly, probably from this file
			return true
		else
			--was likely generated by an event in the main game.
			error("RELOAD_THE_GAME_PLEASE")
		end
	end

function love.handlers.quit()
	if love.audio then
		love.audio.stop()
	end

	if not love.quit or love.quit() then
		error("QUIT_THE_GAME_PLEASE")
	end
end
--}}}
end

--{{{ [[ Custom Error Handling ]]
local ERROR_IN_ERROR_HANDLING = "error in error handling"
local myerror do
	local errfont
	local function set_errfont()
		errfont = lg.getFont()
		local success, font = pcall(
			lg.setNewFont, "assets/DejaVuSansMono.ttf", 11
		)
		if success then
			errfont = font
		end
	end
	if love.window.isOpen() then
		set_errfont()
	end

function myerror(message, level)
	--Special error string matching
	if message == ERROR_IN_ERROR_HANDLING then print("** "..message.." **")end
	if message:match("RELOAD_THE_GAME_PLEASE$") then return true end
	if message:match("QUIT_THE_GAME_PLEASE$") then return false end
	--reset state (from love.errhand)
	if love.mouse then
		love.mouse.setVisible(true)
		love.mouse.setGrabbed(false)
	end
	if love.joystick then
		for i,v in ipairs(love.joystick.getJoysticks()) do
			v:setVibration()
		end
	end
	if love.audio then love.audio.stop() end

	if love.window and love.window.isOpen() then
		if not errfont then set_errfont() end
		lg.setFont(errfont)
		lg.reset()
		lg.setBackgroundColor(0x40/0xff, 0x80/0xff, 0xa0/0xff)
		lg.setColor(1.0, 1.0, 1.0, 1.0)
		lg.origin()
	end
	--end:reset state

	--debug information
	level = (level or 1) + 2
	local info = debug.getinfo(level, "Sl")
	local trace = debug.traceback("", level)
	--end:debug information

	local tinsert, tconcat = table.insert, table.concat
	local pt = {}
	if message:match("HALT_THE_GAME_PLEASE$") then
		tinsert(pt, "Halting Program")
	else
		tinsert(pt, "Error\n")
		if message:match("_PLEASE$") then
			tinsert(pt, "Unrecognized _PLEASE command\n")
		end

		message = string.gsub(message, tracestrip, "")
		tinsert(pt, message)

		--The string matching here is dependent on source files being in src
		--see local variables tracestrip and thisfilestrip
		local levels = level-1
		for l in string.gmatch(trace, "(.-)\n") do
			levels = levels + 1
			if not string.match(l, thisfilestrip) then
				l = string.gsub(l, tracestrip, "\t")
				tinsert(pt, l)
			else
				table.remove(pt) --remove last xpcall reference
				break
			end
		end
		--end:trace line stripping
	end

	tinsert(pt, "\n(R)eload (Esc), (Q)uit, (D)ebug")
	local pts = tconcat(pt, "\n")
	print(pts)

	local stop, rewind = false, false
	local quit_timer = false
	local debugging = false

	if not export("check", "keys2") then
		for k,v in next, export_hal do
			export_hal[k] = nil
		end
		export. hal = export_hal
		export. keys2 = dofile(engine_src_dir.."/keys2.lua")
	end
	local keys2handlers = keys2.getHandlers()
	keys2handlers.quit = function() stop = true end
	--squelch handlers not used
	keys2handlers.visible = false
	keys2handlers.mousefocus = false
	keys2handlers.focus = false

	local keys = keys2.keys
	local midi = keys2.midi


	local dt = 1/20
	while true do
		keys2.doevents()
		love.event.pump()
		for ev,a,b,c,d,e,f in love.event.poll() do
			if keys2handlers[ev] then
				keys2handlers[ev](a,b,c,d,e,f)
			elseif keys2handlers[ev] == nil then
				printf("event %s not recognized", ev)
			end
		end

		for i = 1, keys2.pressed.count do
			local kp = keys2.pressed[i]
			if     kp == "escape" then
				quit_timer = 0
			elseif kp == "q" then
				stop = true
			elseif kp == "r" then
				rewind = true
			elseif kp == "d" then
				tinsert(pt, "- debugging...")
				pts = tconcat(pt, "\n")
				debugging = true
			end
		end
		for i = 1, keys2.released.count do
			local kr = keys2.released[i]
			if kr == "escape" then
				rewind = true
			end
		end

		if quit_timer then
			quit_timer = quit_timer + dt
			if quit_timer > 0.3228 then stop = true end
		end
		if midi(0xb02a) > 0.5 then
			if not midi.saved._hashalted then stop = true end
		else
			midi.saved._hashalted = false
		end

		if stop then
			return false
		end
		if rewind or midi(0xb02b) > 0.5 then
			midi.saved[0xb02b] = 0 --so it doesn't reset in escapekey()
			return love.handlers.reload("donoterror")
		end
		keys2:reset()

		--Render
		lg.clear(lg.getBackgroundColor())
		lg.print(pts, 10, 10)--, lg.getWidth() - 10)
		lg.present()
		--end:Render

		if debugging then
			debug.debug()
			local ptlen = #pt
			pt[ptlen] = pt[ptlen].."done"
			pts = table.concat(pt, "\n")
			debugging = false
		end

		if love.timer then love.timer.sleep(dt) end
	end
end
end --}}} end:custom error handling


function love.run()
	local keepgameopen = false
	if arg[2] == "keepgameopen" then
		table.remove(arg, 2)
		keepgameopen = true
	end

	local error_retries = 0
	while true do
		--loading
		if love.window.isOpen() then
			lg.clear() --clear whatever was in gfx buffer before loading
			lg.present()
		end
		collectgarbage()
		printftime("Starting Program...(%dKB)\n", collectgarbage("count"))
		collectgarbage("stop")
		--end:loading

		local clean, continue = xpcall(function()
			if main2 then
				return main2(arg)
			else
				return require"main2"(arg)
			end
		end, myerror)

		--reload if clean and continue is boolean true
		if clean then break end
		if not continue then break end
		if type(continue) == "string" then
			if continue == ERROR_IN_ERROR_HANDLING then
				myerror(continue)
			end
			print("  **********************************************")
			print(" ************************************************")
			print("**************************************************")
			print("*+----------------------------------------------/ ")
			print("*\\ ")
			print("** Error: \""..continue.."\", ffi is possible culprit")
			print("** Retrying without using custom error handling")
			print("*/ ")
			print("*+----------------------------------------------\\ ")
			print("**************************************************")
			print(" ************************************************")
			print("  **********************************************")
			io.flush()
			love.handlers.reload("donoterror")
			love.timer.sleep(.50)
			if error_retries > 0 then
				print("Retrying once more using custom error handling.")
				error_retries = error_retries + 1
			else
				if main2 then
					main2()
				else
					require"main2"(arg)
				end
				break
			end
		end
	end
	printf("Thank you for playing.\n")

	if keepgameopen then
		printf("Press ENTER to close...")
		love.window.setDisplaySleepEnabled(true)
		love.window.close()
		io.read()
	end
end
